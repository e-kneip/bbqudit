Decoder class:
 -> init takes all decoder specific parameters, eg order, max_iter, ...
 -> Decoder.decode(H, syndrome, error_channel)


TODO
----
 -> allow for different type of error in circuit level simulate...
 -> do z everything as well


Investigate
-----------
 -> field = Field(3)
    x, y = Monomial(field, 'x'), Monomial(field, 'y')
    a = x + x**2 + y**3
    b = y + y**2 + x**3
    bb = BivariateBicycle(a, b, 5, 5, 1)
    has distance estimate = 16 (v high??)

SPEEEEEEEED
-----------
 -> put masks outside loops for _check_to_error/_error_to_check
 -> njit?? lru_cache??
 -> parallelise shots
 -> move ifft/prod outside loop in _check_to_error
 -> ditch galois (/rewrite it)
 -> compare speed of doing Fourier explicitly
 -> follow the profile


BUG
 -> Currently not catching if field is not same as eg h or syndrome, but idk how to check bcos h/syn do not have field associated...



Lil bugs:
 -> should be using the Hx, Hy to make tanner instead of polys?
 -> am I modelling qudit errors right? i.e. with some prob an error occurs and which of Z^k (or X^k) is uniform also for CNOT only do (XY)^k not X^kY^k'
 -> err_cnt might be completely wrong as doing += 1 when apply X^k (or Z^k) error...

Big bugs:
 -> not doing mod in power (ie mod the width of the patch, l, m), will need to extend length of row of coefficients to width of patch and then roll


DISTANCE ESTIMATE
-----------------
 -> do decoder with one row =1 so finds low weight logical
 -> do a big for loop multiplying logicals with stabilisers and checking the weight and take minimum


DO THIS NEXT
------------
 -> initialisation of bbcode uses qubit instead of qudit!!!
 -> update PyPI
 -> reorganise files, make clear what it only for bbq and what is general qudits


FUTURE DIRECTIONS
-----------------
 -> find distance exactly (do approx with decoder)
 -> know when the qudit generalisation makes non-0 k
